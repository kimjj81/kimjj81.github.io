---
title: 맥에서 SD 카드 자동 백업하기
date: 2025-08-13 10:55:44
tags: backup, sd, lauchctl, rsync
---

촬영 데이터를 자동 백업하기 위해서 스크립트를 작성했습니다.

Sequoia 15.6 , rsync 2.6.9 에서 실행해서 잘 되는 것을 확인했습니다.  
rsync 가 설치되어 있지 않다면 설치하세요.  
저는 [Homebrew](https://brew.sh/)로 사용 중입니다.  
물론 Homebrew가 없다면 Homebrew부터 설치하세요.


```
brew install rsync
```

다음은 명령어를 통해서 설치하는 방법입니다. 자동 백업을 위한 설정 파일 하나와 백업 실행파일 하나를 생성합니다.
[설치 스크립트 조각](https://gist.github.com/kimjj81/9eb50a197a0857f58019e085d3104398)을 아래에 풀어 썼습니다.
bash 스크립트라서 터미널에 복붙하면 됩니다.

### 설정 파일 생성

- $HOME/Library/LaunchAgents/com.sd.autobackup.plist 파일을 만드는 스크립트입니다.

```bash
mkdir -p "$HOME/Library/LaunchAgents"
tee "$HOME/Library/LaunchAgents/com.sd.autobackup.plist" >/dev/null <<'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>com.sd.autobackup</string>
    <key>WatchPaths</key>
    <array>
      <string>/Volumes</string>
    </array>
    <key>ProgramArguments</key>
    <array>
      <string>/usr/local/bin/sd_auto_backup.sh</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${HOME}/Library/Logs/sd_auto_backup/agent_stdout.log</string>
    <key>StandardErrorPath</key>
    <string>${HOME}/Library/Logs/sd_auto_backup/agent_stderr.log</string>
  </dict>
</plist>
EOF
```

### 실행파일 생성

- sd_auto_backup.sh 파일을 만드는 스크립트입니다. 아래에서 수정해야 할 것들이 있습니다. 맞게 수정하세요.
- 백업 대상(외장 디스크 루트 볼륨 이름 + 최종 경로)
- VOLUME_NAME <= SD카드의 이름을 넣어주세요. 파인더에서 왼쪽 패널에 "위치"라고 표시된 곳에서 볼 수 있습니다.
- DEST_ROOT_VOLUME <= 백업할 디스크의 볼륨명을 입력하세요. 
- DEST_SUB_DIRECTORY <= 디렉토리를 이용하세요.
- 예제 : 내장 디스크, 내 계정이름 myname , 문서 폴더에 SDCard 디렉토리에 백업한다면
  - VOLUME_NAME="MySDCard"
  - DEST_ROOT_VOLUME="/Volumes/Macintosh\ HD/"
  - DEST_SUB_DIRECTORY="/Users/myname/Documents/SDCard/"
- SKIP_ON_BATTERY=true <= 배터리 전원일 때는 백업을 하지 않습니다.
- ENABLE_DELETE=true <= 목적지에서 원본에 없는 파일을 삭제합니다. 기본은 false 삭제 안합니다.

```bash
#!/usr/bin/env bash
# sd_auto_backup.sh
# - 트리거: launchd(WatchPaths=/Volumes)
# - 조건: 소스 SD 볼륨이 "XXX", 목적지 루트 볼륨 "XXXX" 마운트 시 동기화
# - 기능: rsync 동기화, 구버전 rsync 진행률 옵션 폴백, 중복 실행 방지, 로그, 배터리 전원 시 스킵(플래그)

set -euo pipefail

# =========[ 사용자 설정 ]=========
# 소스 SD 카드 볼륨 이름
VOLUME_NAME="YOUR_SOURCE_VOLUME_NAME"

# 백업 대상(외장 디스크 루트 볼륨 이름 + 최종 경로)
DEST_ROOT_VOLUME="YOUR_BACKUP_VOLUME"
DEST_SUB_DIRECTORY="YOUR_BACKUP_DIRECTORY"
DEST_DIR="/Volumes/${DEST_ROOT_VOLUME}/{DEST_SUB_DIRECTORY}"

# 목적지에서 원본에 없는 파일 삭제 동기화 여부(true/false)
ENABLE_DELETE=false

# 배터리 전원일 때 스킵할지 여부(true=스킵, false=스킵 안 함)
SKIP_ON_BATTERY=true

# 제외 패턴 (필요 시 추가)
EXCLUDES=(
  ".Spotlight-V100"
  ".Trashes"
  ".fseventsd"
  "System Volume Information"
)
# =================================

SRC="/Volumes/${VOLUME_NAME}"
LOG_DIR="$HOME/Library/Logs/sd_auto_backup"
LOG_FILE="$LOG_DIR/backup_$(date +%Y%m%d).log"
LOCK_FILE="$HOME/Library/Caches/sd_auto_backup_${VOLUME_NAME}.lock"

mkdir -p "$LOG_DIR"

log() {
  printf "[%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$*" | tee -a "$LOG_FILE"
}

# 배터리 전원 감지 (AC/UPS/배터리 모두 고려)
on_battery_power() {
  if ! command -v pmset >/dev/null 2>&1; then
    # pmset 없으면 판단 불가 → 배터리 아님으로 간주
    return 1
  fi
  # macOS에서는 아래 출력의 첫 줄에 전원 상태가 표시됩니다.
  # 예) "Now drawing from 'AC Power'" 또는 "Now drawing from 'Battery Power'"
  local line
  line="$(pmset -g ps 2>/dev/null | head -n1 || true)"
  if echo "$line" | grep -q "Battery Power"; then
    return 0
  fi
  # 일부 환경(UPS) 대비
  if echo "$line" | grep -q "UPS Power"; then
    return 0
  fi
  return 1
}

# 중복 실행 방지(최대 120분)
if [ -f "$LOCK_FILE" ]; then
  if [ "$(find "$LOCK_FILE" -mmin +120 2>/dev/null | wc -l)" -gt 0 ]; then
    log "Stale lock detected. Removing $LOCK_FILE"
    rm -f "$LOCK_FILE"
  else
    log "Backup already running. Exit."
    exit 0
  fi
fi
trap 'rm -f "$LOCK_FILE"' EXIT
touch "$LOCK_FILE"

# ---- 배터리 전원 스킵 옵션 ----
if [ "${SKIP_ON_BATTERY}" = true ] && on_battery_power; then
  log "Battery power detected and SKIP_ON_BATTERY=true. Skipping backup."
  exit 0
fi

# ---- 목적지 루트 볼륨(WDBlackDataVolume) 마운트 확인 ----
if ! mount | grep -q "/Volumes/${DEST_ROOT_VOLUME}"; then
  log "Destination root volume '${DEST_ROOT_VOLUME}' not mounted. Skipping backup."
  exit 0
fi

# ---- 소스 SD 카드 마운트 확인 ----
if ! mount | grep -q "/Volumes/${VOLUME_NAME}"; then
  log "Source volume '${VOLUME_NAME}' not mounted. Skipping backup."
  exit 0
fi

# 경로 존재 확인/생성
if [ ! -d "$SRC" ]; then
  log "Source path not found: $SRC"
  exit 1
fi
mkdir -p "$DEST_DIR"

# rsync 바이너리 선택 (Homebrew rsync 우선)
if [ -x "/opt/homebrew/bin/rsync" ]; then
  RSYNC_BIN="/opt/homebrew/bin/rsync"
elif [ -x "/usr/local/bin/rsync" ]; then
  RSYNC_BIN="/usr/local/bin/rsync"
else
  RSYNC_BIN="/usr/bin/rsync"
fi

# rsync 옵션 구성 (버전에 따라 진행 표시 옵션 자동 선택)
RSYNC_OPTS=( -a -v -h )
$ENABLE_DELETE && RSYNC_OPTS+=( --delete )

for p in "${EXCLUDES[@]}"; do
  RSYNC_OPTS+=( --exclude="$p" )
done

# rsync 3.x 이상이면 --info=progress2, 아니면 --progress
if "$RSYNC_BIN" --version 2>/dev/null | head -n1 | grep -qE 'version ([3-9]|[1-9][0-9])\.'; then
  RSYNC_OPTS+=( --info=progress2 --stats )
else
  RSYNC_OPTS+=( --progress --stats )
fi

log "Starting backup: '${SRC}/' -> '${DEST_DIR}/' (using $RSYNC_BIN)"
if "$RSYNC_BIN" "${RSYNC_OPTS[@]}" "$SRC/" "$DEST_DIR/" 2>&1 | tee -a "$LOG_FILE"; then
  log "Backup finished successfully."
  exit 0
else
  log "Backup failed."
  exit 1
fi
```
